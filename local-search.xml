<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【蓝桥杯】C/C++校内模拟赛(持续更新)</title>
    <link href="/2020/03/22/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91C-C-%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2020/03/22/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91C-C-%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p>这次模拟整体难度肯定是比不上正式的省赛的，但是因为种种原因，以及差不多一心情没怎么练习了，所以做的很差，有几个题没来的及看，后面有时间慢慢补上。</p> <a id="more"></a><h2 id="1、填空2"><a href="#1、填空2" class="headerlink" title="1、填空2"></a>1、填空2</h2><p>问题描述<br>　　1200000有多少个约数（只计算正约数）。<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><strong>思路</strong>：没啥思路，考察的很基础。</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int n=1200000,sum=0;    for(int i=1;i&lt;=n;i++){        if(n%i==0){            cout&lt;&lt;i&lt;&lt;endl;            sum++;        }        }    cout&lt;&lt;sum&lt;&lt;endl;    return 0;}</code></pre><h2 id="2、填空1"><a href="#2、填空1" class="headerlink" title="2、填空1"></a>2、填空1</h2><p>问题描述<br>　　在计算机存储中，15.125GB是多少MB？<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><strong>思路</strong>：不需要编程，直接乘就行了</p><p>15.125*1024=15488</p><h2 id="3、填空3"><a href="#3、填空3" class="headerlink" title="3、填空3"></a>3、填空3</h2><p>问题描述<br>　　一棵包含有2019个结点的二叉树，最多包含多少个叶结点？<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><strong>思路</strong><br>数据结构基础知识：（2019+1）/2=1010</p><p>这个其实我考试的时候没想起来，隐约记得这个知识点，后来百度了才想起来，后面要好好看看大二时候的数据结构了。</p><h2 id="4、填空4"><a href="#4、填空4" class="headerlink" title="4、填空4"></a>4、填空4</h2><p>问题描述<br>　　在1至2019中，有多少个数的数位中包含数字9？<br>　　注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><p><strong>思路</strong>：不算太难</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int sum = 0;    for(int i=1;i&lt;=2019;i++){        int t= i;        while(t)        {            if(t%10==9)            {                cout&lt;&lt;i&lt;&lt;endl;                sum++;                break;            }            t/=10;        }    }    cout&lt;&lt;sum&lt;&lt;endl;    return 0;}</code></pre><h2 id="5、代码题1"><a href="#5、代码题1" class="headerlink" title="5、代码题1"></a>5、代码题1</h2><p>问题描述<br>　　小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。<br>　　给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。<br>　　元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。<br>输入格式<br>　　输入一行，包含一个单词，单词中只包含小写英文字母。<br>输出格式<br>　　输出答案，或者为yes，或者为no。<br>样例输入<br>lanqiao<br>样例输出<br>yes<br>样例输入<br>world<br>样例输出<br>no<br>评测用例规模与约定<br>　　对于所有评测用例，单词中的字母个数不超过100。</p><p><strong>思路：</strong>第一段是辅音，第二段是元音，第三个是辅音，第四个是元音 ，用个标记符flag记录“转换的次数”，达到三次就行了。另外！= 和 ^(异或)作用应该是一样的</p><pre><code class="C++">#include &lt;bits/stdc++.h&gt;using namespace std;bool fun(char t){    if(t==&#39;a&#39;||t==&#39;e&#39;||t==&#39;i&#39;||t==&#39;o&#39;||t==&#39;u&#39;)        return true;    else        return false;}int main(){    string s;    cin&gt;&gt;s;    int flag=0;    if(fun(s[0])) //第一个字母为元音直接退出     {        cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;        return 0;    }        for(int i=0;i&lt;s.size();i++){        if(fun(s[i])!=fun(s[i-1]))//第一段是辅音，第二段是元音，第三个是辅音，第四个是元音             flag++;    }    if(flag==3)        cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;    else        cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;    return 0;}</code></pre><h2 id="6、代码题2"><a href="#6、代码题2" class="headerlink" title="6、代码题2"></a>6、代码题2</h2><p>问题描述<br>　　一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。<br>　　给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？<br>输入格式<br>　　输入的第一行包含一个整数 n。<br>输出格式<br>　　输出一行包含一个整数，表示答案。<br>样例输入<br>30<br>样例输出<br>26<br>评测用例规模与约定<br>　　对于 40% 的评测用例，1 &lt;= n &lt;= 1000。<br>　　对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000。<br><strong>思路：</strong>感觉不难，但是编程实现的时候着实费了点力气。主要就是出现了左大于右该如何处理。这里利用if判断的特性，调用函数返回0或者1来记录满足条件的数的个数</p><pre><code class="C++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int n,sum=0,l,r;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){    int t=i,right=i%10;            while(t) {                t=t/10;                 int left=t%10;                if((left&gt;right) {                    break;                }                left=right;                t=t/10;            }            if(!t)             sum++;}        printf(&quot;%d\n&quot;,sum);} </code></pre><h2 id="7、代码题3"><a href="#7、代码题3" class="headerlink" title="7、代码题3"></a>7、代码题3</h2><p>问题描述<br>　　在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。<br>　　给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。<br>输入格式<br>　　输入的第一行包含一个整数 n。<br>　　第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。<br>输出格式<br>　　输出一行包含一个整数，表示答案。<br>样例输入<br>5<br>1 2 5 3 5<br>样例输出<br>2<br>样例说明<br>　　a[2] 和 a[4] 可能是三元组的中心。<br>评测用例规模与约定<br>　　对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。<br>　　对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。</p><p><strong>思路：</strong>还没来得及看</p><pre><code></code></pre><h2 id="8、代码题4"><a href="#8、代码题4" class="headerlink" title="8、代码题4"></a>8、代码题4</h2><p>问题描述<br>　　小明想知道，满足以下条件的正整数序列的数量：<br>　　1. 第一项为 n；<br>　　2. 第二项不超过 n；<br>　　3. 从第三项开始，每一项小于前两项的差的绝对值。<br>　　请计算，对于给定的 n，有多少种满足条件的序列。<br>输入格式<br>　　输入一行包含一个整数 n。<br>输出格式<br>　　输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。<br>样例输入<br>4<br>样例输出<br>7<br>样例说明<br>　　以下是满足条件的序列：<br>　　4 1<br>　　4 1 1<br>　　4 1 2<br>　　4 2<br>　　4 2 1<br>　　4 3<br>　　4 4<br>评测用例规模与约定<br>　　对于 20% 的评测用例，1 &lt;= n &lt;= 5；<br>　　对于 50% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 80% 的评测用例，1 &lt;= n &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000。<br><strong>思路：</strong>应该是个DP问题，我甚至都不打算看了……</p><pre><code></code></pre><h2 id="9、代码题5"><a href="#9、代码题5" class="headerlink" title="9、代码题5"></a>9、代码题5</h2><p>问题描述<br>　　小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。<br>　　小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。<br>　　这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。<br>　　请告诉小明，k 个月后空地上哪些地方有草。<br>输入格式<br>　　输入的第一行包含两个整数 n, m。<br>　　接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。<br>　　接下来包含一个整数 k。<br>输出格式<br>　　输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。<br>样例输入<br>4 5<br>.g…<br>…<br>…g…<br>…<br>2<br>样例输出<br>gggg.<br>gggg.<br>ggggg<br>.ggg.<br>评测用例规模与约定<br>　　对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。<br>　　对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。<br>　　对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。<br><strong>思路：</strong>感觉不是很难，没来得及细看</p><pre><code></code></pre><h2 id="10、代码题6"><a href="#10、代码题6" class="headerlink" title="10、代码题6"></a>10、代码题6</h2><p>问题描述<br>　　小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。<br>　　这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。<br>　　小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。<br>　　小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。<br>输入格式<br>　　输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。<br>　　第二行包含 n 个整数，依次为每个节目的好看值。<br>输出格式<br>　　输出一行包含 m 个整数，为选出的节目的好看值。<br>样例输入<br>5 3<br>3 1 2 5 4<br>样例输出<br>3 5 4<br>样例说明<br>　　选择了第1, 4, 5个节目。<br>评测用例规模与约定<br>　　对于 30% 的评测用例，1 &lt;= n &lt;= 20；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。<br><strong>思路：</strong>考察了sort函数的cmp参数，但是感觉简单过头了啊，是不是我理解错了？等后面成绩出来再看看吧</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000;bool cmp(int x,int y){    return x &gt; y;}int main(){    int n,m,a[maxn],t[maxn];    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;a[i];        t[i]=a[i];    }    sort(a,a+n,cmp);    int tmp=a[m];    for(int i=0;i&lt;n;i++)    {        if(t[i]&gt;tmp)            cout&lt;&lt;t[i]&lt;&lt;&quot; &quot;;    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法笔记01】川大夏令营-约瑟夫环</title>
    <link href="/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B001%E3%80%91%E5%B7%9D%E5%A4%A7%E5%A4%8F%E4%BB%A4%E8%90%A5-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    <url>/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B001%E3%80%91%E5%B7%9D%E5%A4%A7%E5%A4%8F%E4%BB%A4%E8%90%A5-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="约瑟夫环问题描述"><a href="#约瑟夫环问题描述" class="headerlink" title="约瑟夫环问题描述"></a>约瑟夫环问题描述</h2><p>已知<strong>n</strong>个人围成一圈（编号：1，2，3，…，n），从编号为1的人开始报数，报数为<strong>m</strong>的那个人出列；从他的下一个人又从1开始数，同样报数为<strong>m</strong>的人出列；依此循环下去，直到剩余一个人。<strong>求最后这一个人在最开始的序列中编号是几号？</strong></p> <a id="more"></a><h2 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h2><p>刚学数据结构的时候，我们可能用链表的方法去模拟这个过程，N个人看作是N个链表节点，节点1指向节点2，节点2指向节点3，……，节点N-1指向节点N，节点N指向节点1，这样就形成了一个环。然后从节点1开始1、2、3……往下报数，每报到M，就把那个节点从环上删除。下一个节点接着从1开始报数。最终链表仅剩一个节点。它就是最终的胜利者。</p><p>PS:这个是网上随便找的，等有空再更新</p><pre><code class="c">#include &lt;cstdio&gt;int n,k;struct node{    int x;    node *next;    node(int c):x(c),next(NULL){}};node *first=NULL;int main(){    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);    node *last=new node(1);    first=last;    for(int i=2;i&lt;=n;i++)    last-&gt;next=new node(i),last=last-&gt;next;    last-&gt;next=first;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;k;j++)        last=first,first=first-&gt;next;        printf(&quot;%d &quot;,first-&gt;x);        last-&gt;next=first-&gt;next;        first=first-&gt;next;    }}</code></pre><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>要模拟整个游戏过程，时间复杂度高达O(nm)，当n，m非常大(例如上百万，上千万)的时候，几乎是没有办法在短时间内出结果的。</p><h2 id="递归求解分析"><a href="#递归求解分析" class="headerlink" title="递归求解分析"></a>递归求解分析</h2><p>将这n个人从0~n-1编号（1是习惯从0开始；2是如果m大于等于n时，第一个出列的人编号是m%n，m%n可能等于0，简化后续序列的模式化处理），则报数为m-1的人出列，最后结果加1就为原问题的解，以下，我们来分析出列的过程：</p><p>第一次出列-n阶约瑟夫环的问题（n个人）<br>0，1，2，3，4，5，…，n-2，n-1<br>第一次出列的人的编号为<strong>(m-1)%n1</strong>（记n1为第一次编号的总人数），从他的下一个人又开始从0开始报数，为了方便我们记k1=m%n1，如下：<br>0，1，2，3，4，5，…，k1-1(第一次出列人的编号(m-1)%n1)，k1，k1+1，…，n-2，n-1</p><p>由于第二次出列是是从k1开始，又从0开始报数，为了便于模式化我们将第一次出列后的序列排序如下：<br>k1，k1+1，k1+2，…，n-2，n-1，0，1，2，3，4，5，…，k1-3，k1-2（k1-1第一次已经出列）</p><p>第二次出列-n-1阶约瑟夫环问题（n-1个人）<br>对上述序列重新编号：<br>0，1，2，3，4，5，…，n-2<br>第二次出列的人的编号为<strong>(m-1)%n2</strong>（记n2为第一次编号的总人数），从他的下一个人又开始从0开始报数，为了方便我们记k2=m%n2，如下：<br>0，1，2，3，4，5，…，k2-1(第二次出列人的编号(m-1)%n2)，k2，k2+1，…，n-2<br>同样重新排序如下：<br>k2，k2+1，k2+2，…，n-2，n-1，0，1，2，3，4，5，…，k2-3，k2-2（k2-1第二次已经出列）</p><p>第三次出列-n-2阶约瑟夫环问题（n-2个人）<br>对上述序列重新编号：<br>0，1，2，3，4，5，…，n-3<br>…</p><p>第N-1次出列-2阶约瑟夫环问题（2个人）<br>k(n-1)，k(n-1)+1<br>重新编号：<br>0，1<br>第n-1次出列的人的编号为：m%n(n-1)，记下一个人的为k(n-1)=m%n2<br>k(n-1)</p><p>第N次出列-1阶约瑟夫环问题（1个人）<br>对上述序列重新编号：<br>0<br>直接得出结果为0。</p><h2 id="结论总结"><a href="#结论总结" class="headerlink" title="结论总结"></a>结论总结</h2><p>以上我们将问题转换为模式相同且规模逐渐缩小的问题，当规模最小即只有一个人n=1时，报数为m-1的人出列，最后出列的人编号为0；当n=2时，报数为m-1的人出列，最后出列人的编号是多少？应该是只有一个人时得到最后出列的序号加上m（因为报数为m-1的人已经出列，剩下那个人才最后出列所以才加上m）<br>n=1时，f(1)=0；<br>n=2时，f(2)=[f(1)+m]%2；<br>n=3时，f(3)=[f(2)+m]%3；<br>验证结果：2个人围成一圈，数到3的那人出列，求最后那个人的编号？n=2，m=3<br>f(2)=[f(1)+m]%2=[0+3]%2=1<br>最后结果加1，则result=2；</p><p>代码：</p><pre><code class="c++">#include&lt;stdio.h&gt;int fun(int n,int m){ if(n==1)  return 0; else   return (fun(n-1,m)+m)%n;}int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; int count=fun(n,m); cout&gt;&gt;count+1&gt;&gt;endl; return 0;} </code></pre><h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p>f(1)=0；//递归出口<br>f(n)=[f(n-1)+m]%n；//递归体`</p><p>这里就不用归纳法了，时间复杂度太高，直接从上述总结公式</p><p><strong>递推公式：</strong><br>$$<br>f(N,M)=(f(N−1,M)+M)<br>$$</p><ul><li>$f(N,M)$表示，N个人报数，每报到M时出列那个人，最终胜利者的编号</li><li>$f(N−1,M)$表示，N-1个人报数，每报到M时出列那个人，最终胜利者的编号</li></ul><pre><code class="c">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,m=3; cin&gt;&gt;n; int ans=0,i=0; for(i=1;i&lt;=n;i++){  ans=(ans+m)%i; } cout&lt;&lt;ans+1; return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
