<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【蓝桥杯】小数的第n位</title>
    <link href="/2020/04/02/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%B0%8F%E6%95%B0%E7%9A%84%E7%AC%ACn%E4%BD%8D/"/>
    <url>/2020/04/02/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%B0%8F%E6%95%B0%E7%9A%84%E7%AC%ACn%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p>很久没有练习了，下一阶段开始看真题训练。这一题看起来很简单但是处理起来比较棘手。主要有两种做法，一种是模拟（网上有的模拟需要用队列来优化循环防止超时，但是我看到的这个博主的做法很巧妙，所以记录下来）。第二种是求逆元，需要一些初等数论的知识，具体证明在算法笔记的176页，后续更新。 </p><a id="more"></a><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>时间限制：1.0s  内存限制：256.0MB</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。<br>　　如果我们把有限小数的末尾加上无限多个0，它们就有了统一的形式。</p><p>　　本题的任务是：在上面的约定下，求整数除法小数点后的第n位开始的3位数。</p><p>输入格式</p><p>　　一行三个整数：a b n，用空格分开。a是被除数，b是除数，n是所求的小数后位置（0&lt;a,b,n&lt;1000000000）</p><p>输出格式</p><p>　　一行3位数字，表示：a除以b，小数后第n位开始的3位数字。</p><p>样例输入</p><p>1 8 1</p><p>样例输出</p><p>125</p><p>样例输入</p><p>1 8 3</p><p>样例输出</p><p>500</p><p>样例输入</p><p>282866 999000 6</p><p>样例输出</p><p>914</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个问题看起来很简单，但是处理起来是很麻烦的，网上主流的有两种解决方法，第一种是模拟，但是不能用暴力的方法，不然会超时，我们可以利用数学方法巧妙地解决。</p><p>例如计算1/13的第13（即n=13）位小数，结果是0.33333…..，如果我们将这个结果乘以1*10^10，就变成了3333333333.3333……，利用这种方法可以减小n的数值。</p><p>对于这个例子，我们吧1*10^10%3的余数为1，次数n=n-10，即n=3；说明我们只需要对余数1再模拟出发运算三次就可以得到我们要的三个数的第一位数，运算两次就可以得到第二位和第三位小数。</p><pre><code class="c++">#include&lt;bits/stdc++&gt;using namespace std;typedef long long ll;int mian(){  ll a;  ll b;  int n;  cin&gt;&gt;a&gt;&gt;b&gt;&gt;n;  while(n-10&gt;0){//快速缩小n，逼近第n位    a*=1e10;    a%=b;    n-=10;  }  for(int i=0;i&lt;n+2;i++){    a*=10;//①因为之前对b取余得到的，所以此时的a一定小于吧，对a*10，在b取余时可以获得一位数    if(i&gt;n-1){      cout&lt;&lt;a/b;    }    a%=b;//①中说的取余  }  return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【蓝桥杯】C/C++校内模拟赛(持续更新)</title>
    <link href="/2020/03/22/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91C-C-%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%20%E4%B8%8B%E5%8D%8811.30.04/"/>
    <url>/2020/03/22/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91C-C-%E6%A0%A1%E5%86%85%E6%A8%A1%E6%8B%9F%E8%B5%9B-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%20%E4%B8%8B%E5%8D%8811.30.04/</url>
    
    <content type="html"><![CDATA[<p>这次模拟整体难度肯定是比不上正式的省赛的，但是因为种种原因，以及差不多一心情没怎么练习了，所以做的很差，有几个题没来的及看，后面有时间慢慢补上。</p><p><strong>3-22 更新1，2，3，4，5，6，10（该题完全错误）</strong></p><p><strong>3-26 更新7，8（bfs模板题）</strong></p> <a id="more"></a><h2 id="1、填空2"><a href="#1、填空2" class="headerlink" title="1、填空2"></a>1、填空2</h2><p>问题描述<br>　　1200000有多少个约数（只计算正约数）。<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><strong>思路</strong>：没啥思路，考察的很基础。</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int n=1200000,sum=0;    for(int i=1;i&lt;=n;i++){        if(n%i==0){            cout&lt;&lt;i&lt;&lt;endl;            sum++;        }        }    cout&lt;&lt;sum&lt;&lt;endl;    return 0;}</code></pre><h2 id="2、填空1"><a href="#2、填空1" class="headerlink" title="2、填空1"></a>2、填空1</h2><p>问题描述<br>　　在计算机存储中，15.125GB是多少MB？<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><strong>思路</strong>：不需要编程，直接乘就行了</p><p>15.125*1024=15488</p><h2 id="3、填空3"><a href="#3、填空3" class="headerlink" title="3、填空3"></a>3、填空3</h2><p>问题描述<br>　　一棵包含有2019个结点的二叉树，最多包含多少个叶结点？<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。<br><strong>思路</strong><br>数据结构基础知识：（2019+1）/2=1010</p><p>这个其实我考试的时候没想起来，隐约记得这个知识点，后来百度了才想起来，后面要好好看看大二时候的数据结构了。</p><h2 id="4、填空4"><a href="#4、填空4" class="headerlink" title="4、填空4"></a>4、填空4</h2><p>问题描述<br>　　在1至2019中，有多少个数的数位中包含数字9？<br>　　注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。<br>答案提交<br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><p><strong>思路</strong>：不算太难</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int sum = 0;    for(int i=1;i&lt;=2019;i++){        int t= i;        while(t)        {            if(t%10==9)            {                cout&lt;&lt;i&lt;&lt;endl;                sum++;                break;            }            t/=10;        }    }    cout&lt;&lt;sum&lt;&lt;endl;    return 0;}</code></pre><h2 id="5、代码题1"><a href="#5、代码题1" class="headerlink" title="5、代码题1"></a>5、代码题1</h2><p>问题描述<br>　　小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。<br>　　给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。<br>　　元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。<br>输入格式<br>　　输入一行，包含一个单词，单词中只包含小写英文字母。<br>输出格式<br>　　输出答案，或者为yes，或者为no。<br>样例输入<br>lanqiao<br>样例输出<br>yes<br>样例输入<br>world<br>样例输出<br>no<br>评测用例规模与约定<br>　　对于所有评测用例，单词中的字母个数不超过100。</p><p><strong>思路：</strong>第一段是辅音，第二段是元音，第三个是辅音，第四个是元音 ，用个标记符flag记录“转换的次数”，达到三次就行了。另外！= 和 ^(异或)作用应该是一样的</p><pre><code class="C++">#include &lt;bits/stdc++.h&gt;using namespace std;bool fun(char t){    if(t==&#39;a&#39;||t==&#39;e&#39;||t==&#39;i&#39;||t==&#39;o&#39;||t==&#39;u&#39;)        return true;    else        return false;}int main(){    string s;    cin&gt;&gt;s;    int flag=0;    if(fun(s[0])) //第一个字母为元音直接退出     {        cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;        return 0;    }        for(int i=0;i&lt;s.size();i++){        if(fun(s[i])!=fun(s[i-1]))//第一段是辅音，第二段是元音，第三个是辅音，第四个是元音             flag++;    }    if(flag==3)        cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;    else        cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;    return 0;}</code></pre><h2 id="6、代码题2"><a href="#6、代码题2" class="headerlink" title="6、代码题2"></a>6、代码题2</h2><p>问题描述<br>　　一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。<br>　　给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？<br>输入格式<br>　　输入的第一行包含一个整数 n。<br>输出格式<br>　　输出一行包含一个整数，表示答案。<br>样例输入<br>30<br>样例输出<br>26<br>评测用例规模与约定<br>　　对于 40% 的评测用例，1 &lt;= n &lt;= 1000。<br>　　对于 80% 的评测用例，1 &lt;= n &lt;= 100000。<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000。<br><strong>思路：</strong>感觉不难，但是编程实现的时候着实费了点力气。主要就是出现了左大于右该如何处理。这里利用if判断的特性，调用函数返回0或者1来记录满足条件的数的个数</p><pre><code class="C++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int n,sum=0,l,r;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){    int t=i,right=i%10;            while(t) {                t=t/10;                 int left=t%10;                if((left&gt;right) {                    break;                }                left=right;                t=t/10;            }            if(!t)             sum++;}        printf(&quot;%d\n&quot;,sum);} </code></pre><h2 id="7、代码题3"><a href="#7、代码题3" class="headerlink" title="7、代码题3"></a>7、代码题3</h2><p>问题描述<br>　　在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。<br>　　给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。<br>输入格式<br>　　输入的第一行包含一个整数 n。<br>　　第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。<br>输出格式<br>　　输出一行包含一个整数，表示答案。<br>样例输入<br>5<br>1 2 5 3 5<br>样例输出<br>2<br>样例说明<br>　　a[2] 和 a[4] 可能是三元组的中心。<br>评测用例规模与约定<br>　　对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。<br>　　对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。</p><p><strong>思路：</strong>枚举。数据规模不大，暴力怼就完事了。</p><p>枚举每个元素，寻找比该元素之前小的和该元素之后大的，两个条件位真，ans++;</p><pre><code class="C++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){    int n,ans=0;    cin&gt;&gt;n;    int data[n];    for(int i=0;i&lt;n;i++){        cin&gt;&gt;data[i];    }    for(int i=1;i&lt;=n-1;i++){        int hasSmall = 0;        for(int j=0;j&lt;i;j++){            if(data[j]&lt;data[i]){                hasSmall=1;                break;            }        }        int hasBig = 0;        for(int k=i+1;k&lt;n;k++){            if(data[k]&gt;data[i]){                hasBig=1;                break;            }        }        if(hasSmall&amp;&amp;hasBig)        ans++;    }    cout&lt;&lt;ans&lt;&lt;endl;    return 0;} </code></pre><h2 id="8、代码题4"><a href="#8、代码题4" class="headerlink" title="8、代码题4"></a>8、代码题4</h2><p>问题描述<br>　　小明想知道，满足以下条件的正整数序列的数量：<br>　　1. 第一项为 n；<br>　　2. 第二项不超过 n；<br>　　3. 从第三项开始，每一项小于前两项的差的绝对值。<br>　　请计算，对于给定的 n，有多少种满足条件的序列。<br>输入格式<br>　　输入一行包含一个整数 n。<br>输出格式<br>　　输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。<br>样例输入<br>4<br>样例输出<br>7<br>样例说明<br>　　以下是满足条件的序列：<br>　　4 1<br>　　4 1 1<br>　　4 1 2<br>　　4 2<br>　　4 2 1<br>　　4 3<br>　　4 4<br>评测用例规模与约定<br>　　对于 20% 的评测用例，1 &lt;= n &lt;= 5；<br>　　对于 50% 的评测用例，1 &lt;= n &lt;= 10；<br>　　对于 80% 的评测用例，1 &lt;= n &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000。<br><strong>思路：</strong>应该是个DP问题，我甚至都不打算看了……</p><pre><code></code></pre><h2 id="9、代码题5"><a href="#9、代码题5" class="headerlink" title="9、代码题5"></a>9、代码题5</h2><p>问题描述<br>　　小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。<br>　　小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。<br>　　这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。<br>　　请告诉小明，k 个月后空地上哪些地方有草。<br>输入格式<br>　　输入的第一行包含两个整数 n, m。<br>　　接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。<br>　　接下来包含一个整数 k。<br>输出格式<br>　　输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。<br>样例输入<br>4 5<br>.g…<br>…<br>…g…<br>…<br>2<br>样例输出<br>gggg.<br>gggg.<br>ggggg<br>.ggg.<br>评测用例规模与约定<br>　　对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。<br>　　对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。<br>　　对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。<br><strong>思路：</strong>典型的bfs，基本是个模板题。时间复杂度最多为O(N*M)。</p><p>下面贴的是老师写的代码，是bfs的板子，但是写法不是很常规，有很多东西书上都没有写，关于bfs和dfs，这俩是大二上学期数据结构重点上的，但是我们的水货老师根本没怎么讲- -，最后也没考，所有就没怎么复习，但是既然开始学习算法了，就应该好好学一下，周六周日的时候会写两篇文章好好的复习一下这两个算法。</p><pre><code class="C++">#include &lt;iostream&gt;#include &lt;queue&gt;#define loop(i, x, y) for(register int i = x;i &lt;= y;i++)using namespace std;//草地上的一块struct block {    int i;    int j;    int month;};const int dx[] = {1, 0, -1, 0};const int dy[] = {0, 1, 0, -1};int vis[1000][1000]{};int N, M, K;int main() {    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    //freopen(&quot;in&quot;, &quot;r&quot;, stdin);    //freopen(&quot;out&quot;, &quot;w&quot;, stdout);    int a = clock();    cin &gt;&gt; N &gt;&gt; M;    queue&lt;block&gt; q;    char next_char;    cin.get(next_char);    while (next_char != &#39;\n&#39;)cin.get(next_char);    loop(i, 0, N - 1) {        loop(j, 0, M - 1) {            cin.get(next_char);            if (next_char == &#39;g&#39;) {                q.push({i, j, 0});                vis[i][j] = 1;            }        }        cin.get(next_char);        while (next_char != &#39;\n&#39;)cin.get(next_char);    }    cin &gt;&gt; K;    while (!q.empty()) {        block b = q.front();        q.pop();        int month = b.month;        if (month &lt; K) {            loop(i, 0, 3) {                int nx = b.i + dx[i];                int ny = b.j + dy[i];                if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; vis[nx][ny] == 0) {                    vis[nx][ny] = 1;                    q.push({nx, ny, month + 1});                }            }        }    }    loop(i, 0, N - 1) {        loop(j, 0, M - 1) {            if (vis[i][j] == 1) cout &lt;&lt; &#39;g&#39;;            else cout &lt;&lt; &#39;.&#39;;        }        cout &lt;&lt; endl;    }    clog &lt;&lt; clock() - a &lt;&lt; endl;    return 0;}</code></pre><p><strong>常规写法：</strong></p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;#define MAXN 1007using namespace std;struct Point { int x,y,c; };int n,m,k,way[4][2]={{1,0},{-1,0},{0,1},{0,-1}};char dt[MAXN][MAXN]; bool f[MAXN][MAXN];queue&lt;Point&gt; Q;int main() {    memset(f,0,sizeof(f));    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for (int i=0;i&lt;n;i++) {        scanf(&quot;%s&quot;,dt[i]);        for (int j=0;j&lt;m;j++)            if (dt[i][j]==&#39;g&#39;)                f[i][j]=true,Q.push((Point){i,j,0});    }    scanf(&quot;%d&quot;,&amp;k);    while(!Q.empty()) {        Point now=Q.front(); Q.pop();        if (now.c==k) break;        for (int i=0;i&lt;4;i++) {            int tx=now.x+way[i][0],ty=now.y+way[i][1];            if (tx&lt;0 || tx&gt;n || ty&lt;0 || ty&gt;m) continue;            dt[tx][ty]=&#39;g&#39;;            if (!f[tx][ty]) Q.push((Point){tx,ty,now.c+1});        }    }    for (int i=0;i&lt;n;i++) printf(&quot;%s\n&quot;,dt[i]);    return 0;}</code></pre><h2 id="10、代码题6"><a href="#10、代码题6" class="headerlink" title="10、代码题6"></a>10、代码题6</h2><p>问题描述<br>　　小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。<br>　　这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。<br>　　小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。<br>　　小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。<br>输入格式<br>　　输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。<br>　　第二行包含 n 个整数，依次为每个节目的好看值。<br>输出格式<br>　　输出一行包含 m 个整数，为选出的节目的好看值。<br>样例输入<br>5 3<br>3 1 2 5 4<br>样例输出<br>3 5 4<br>样例说明<br>　　选择了第1, 4, 5个节目。<br>评测用例规模与约定<br>　　对于 30% 的评测用例，1 &lt;= n &lt;= 20；<br>　　对于 60% 的评测用例，1 &lt;= n &lt;= 100；<br>　　对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。<br><strong>思路：</strong>考察了sort函数的cmp参数，但是感觉简单过头了啊，是不是我理解错了？等后面成绩出来再看看吧</p><pre><code class="c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000;bool cmp(int x,int y){    return x &gt; y;}int main(){    int n,m,a[maxn],t[maxn];    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++){        cin&gt;&gt;a[i];        t[i]=a[i];    }    sort(a,a+n,cmp);    int tmp=a[m];    for(int i=0;i&lt;n;i++)    {        if(t[i]&gt;tmp)            cout&lt;&lt;t[i]&lt;&lt;&quot; &quot;;    }    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法笔记01】川大夏令营-约瑟夫环</title>
    <link href="/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B001%E3%80%91%E5%B7%9D%E5%A4%A7%E5%A4%8F%E4%BB%A4%E8%90%A5-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    <url>/2020/03/21/%E3%80%90%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B001%E3%80%91%E5%B7%9D%E5%A4%A7%E5%A4%8F%E4%BB%A4%E8%90%A5-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="约瑟夫环问题描述"><a href="#约瑟夫环问题描述" class="headerlink" title="约瑟夫环问题描述"></a>约瑟夫环问题描述</h2><p>已知<strong>n</strong>个人围成一圈（编号：1，2，3，…，n），从编号为1的人开始报数，报数为<strong>m</strong>的那个人出列；从他的下一个人又从1开始数，同样报数为<strong>m</strong>的人出列；依此循环下去，直到剩余一个人。<strong>求最后这一个人在最开始的序列中编号是几号？</strong></p> <a id="more"></a><h2 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h2><p>刚学数据结构的时候，我们可能用链表的方法去模拟这个过程，N个人看作是N个链表节点，节点1指向节点2，节点2指向节点3，……，节点N-1指向节点N，节点N指向节点1，这样就形成了一个环。然后从节点1开始1、2、3……往下报数，每报到M，就把那个节点从环上删除。下一个节点接着从1开始报数。最终链表仅剩一个节点。它就是最终的胜利者。</p><p>PS:这个是网上随便找的，等有空再更新</p><pre><code class="c">#include &lt;cstdio&gt;int n,k;struct node{    int x;    node *next;    node(int c):x(c),next(NULL){}};node *first=NULL;int main(){    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);    node *last=new node(1);    first=last;    for(int i=2;i&lt;=n;i++)    last-&gt;next=new node(i),last=last-&gt;next;    last-&gt;next=first;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;k;j++)        last=first,first=first-&gt;next;        printf(&quot;%d &quot;,first-&gt;x);        last-&gt;next=first-&gt;next;        first=first-&gt;next;    }}</code></pre><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>要模拟整个游戏过程，时间复杂度高达O(nm)，当n，m非常大(例如上百万，上千万)的时候，几乎是没有办法在短时间内出结果的。</p><h2 id="递归求解分析"><a href="#递归求解分析" class="headerlink" title="递归求解分析"></a>递归求解分析</h2><p>将这n个人从0~n-1编号（1是习惯从0开始；2是如果m大于等于n时，第一个出列的人编号是m%n，m%n可能等于0，简化后续序列的模式化处理），则报数为m-1的人出列，最后结果加1就为原问题的解，以下，我们来分析出列的过程：</p><p>第一次出列-n阶约瑟夫环的问题（n个人）<br>0，1，2，3，4，5，…，n-2，n-1<br>第一次出列的人的编号为<strong>(m-1)%n1</strong>（记n1为第一次编号的总人数），从他的下一个人又开始从0开始报数，为了方便我们记k1=m%n1，如下：<br>0，1，2，3，4，5，…，k1-1(第一次出列人的编号(m-1)%n1)，k1，k1+1，…，n-2，n-1</p><p>由于第二次出列是是从k1开始，又从0开始报数，为了便于模式化我们将第一次出列后的序列排序如下：<br>k1，k1+1，k1+2，…，n-2，n-1，0，1，2，3，4，5，…，k1-3，k1-2（k1-1第一次已经出列）</p><p>第二次出列-n-1阶约瑟夫环问题（n-1个人）<br>对上述序列重新编号：<br>0，1，2，3，4，5，…，n-2<br>第二次出列的人的编号为<strong>(m-1)%n2</strong>（记n2为第一次编号的总人数），从他的下一个人又开始从0开始报数，为了方便我们记k2=m%n2，如下：<br>0，1，2，3，4，5，…，k2-1(第二次出列人的编号(m-1)%n2)，k2，k2+1，…，n-2<br>同样重新排序如下：<br>k2，k2+1，k2+2，…，n-2，n-1，0，1，2，3，4，5，…，k2-3，k2-2（k2-1第二次已经出列）</p><p>第三次出列-n-2阶约瑟夫环问题（n-2个人）<br>对上述序列重新编号：<br>0，1，2，3，4，5，…，n-3<br>…</p><p>第N-1次出列-2阶约瑟夫环问题（2个人）<br>k(n-1)，k(n-1)+1<br>重新编号：<br>0，1<br>第n-1次出列的人的编号为：m%n(n-1)，记下一个人的为k(n-1)=m%n2<br>k(n-1)</p><p>第N次出列-1阶约瑟夫环问题（1个人）<br>对上述序列重新编号：<br>0<br>直接得出结果为0。</p><h2 id="结论总结"><a href="#结论总结" class="headerlink" title="结论总结"></a>结论总结</h2><p>以上我们将问题转换为模式相同且规模逐渐缩小的问题，当规模最小即只有一个人n=1时，报数为m-1的人出列，最后出列的人编号为0；当n=2时，报数为m-1的人出列，最后出列人的编号是多少？应该是只有一个人时得到最后出列的序号加上m（因为报数为m-1的人已经出列，剩下那个人才最后出列所以才加上m）<br>n=1时，f(1)=0；<br>n=2时，f(2)=[f(1)+m]%2；<br>n=3时，f(3)=[f(2)+m]%3；<br>验证结果：2个人围成一圈，数到3的那人出列，求最后那个人的编号？n=2，m=3<br>f(2)=[f(1)+m]%2=[0+3]%2=1<br>最后结果加1，则result=2；</p><p>代码：</p><pre><code class="c++">#include&lt;stdio.h&gt;int fun(int n,int m){ if(n==1)  return 0; else   return (fun(n-1,m)+m)%n;}int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; int count=fun(n,m); cout&gt;&gt;count+1&gt;&gt;endl; return 0;} </code></pre><h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p>f(1)=0；//递归出口<br>f(n)=[f(n-1)+m]%n；//递归体`</p><p>这里就不用归纳法了，时间复杂度太高，直接从上述总结公式</p><p><strong>递推公式：</strong><br>$$<br>f(N,M)=(f(N−1,M)+M)<br>$$</p><ul><li>$f(N,M)$表示，N个人报数，每报到M时出列那个人，最终胜利者的编号</li><li>$f(N−1,M)$表示，N-1个人报数，每报到M时出列那个人，最终胜利者的编号</li></ul><pre><code class="c">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,m=3; cin&gt;&gt;n; int ans=0,i=0; for(i=1;i&lt;=n;i++){  ans=(ans+m)%i; } cout&lt;&lt;ans+1; return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
